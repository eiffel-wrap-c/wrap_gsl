note

	description: "This file has been generated by EWG. Do not edit. Changes will be lost!"

	generator: "Eiffel Wrapper Generator"

class GSL_MULTIFIT_ROBUST_WORKSPACE_STRUCT_API

inherit

	MEMORY_STRUCTURE

	
create

	make,
	make_by_pointer

feature -- Measurement

	structure_size: INTEGER 
		do
			Result := sizeof_external
		end

feature {ANY} -- Member Access

	n: INTEGER
			-- Access member `n`
		require
			exists: exists
		do
			Result := c_n (item)
		ensure
			result_correct: Result = c_n (item)
		end

	set_n (a_value: INTEGER) 
			-- Change the value of member `n` to `a_value`.
		require
			exists: exists
		do
			set_c_n (item, a_value)
		ensure
			n_set: a_value = n
		end

	p: INTEGER
			-- Access member `p`
		require
			exists: exists
		do
			Result := c_p (item)
		ensure
			result_correct: Result = c_p (item)
		end

	set_p (a_value: INTEGER) 
			-- Change the value of member `p` to `a_value`.
		require
			exists: exists
		do
			set_c_p (item, a_value)
		ensure
			p_set: a_value = p
		end

	numit: INTEGER
			-- Access member `numit`
		require
			exists: exists
		do
			Result := c_numit (item)
		ensure
			result_correct: Result = c_numit (item)
		end

	set_numit (a_value: INTEGER) 
			-- Change the value of member `numit` to `a_value`.
		require
			exists: exists
		do
			set_c_numit (item, a_value)
		ensure
			numit_set: a_value = numit
		end

	maxiter: INTEGER
			-- Access member `maxiter`
		require
			exists: exists
		do
			Result := c_maxiter (item)
		ensure
			result_correct: Result = c_maxiter (item)
		end

	set_maxiter (a_value: INTEGER) 
			-- Change the value of member `maxiter` to `a_value`.
		require
			exists: exists
		do
			set_c_maxiter (item, a_value)
		ensure
			maxiter_set: a_value = maxiter
		end

	type: detachable GSL_MULTIFIT_ROBUST_TYPE_STRUCT_API 
			-- Access member `type`
		require
			exists: exists
		do
			if attached c_type (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_type (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_type (item) 
		end

	set_type (a_value: GSL_MULTIFIT_ROBUST_TYPE_STRUCT_API) 
			-- Set member `type`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_type (item, a_value.item)
		ensure
			type_set: attached type as l_value implies l_value.item = a_value.item
		end

	tune: REAL_64
			-- Access member `tune`
		require
			exists: exists
		do
			Result := c_tune (item)
		ensure
			result_correct: Result = c_tune (item)
		end

	set_tune (a_value: REAL_64) 
			-- Change the value of member `tune` to `a_value`.
		require
			exists: exists
		do
			set_c_tune (item, a_value)
		ensure
			tune_set: a_value = tune
		end

	r: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `r`
		require
			exists: exists
		do
			if attached c_r (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_r (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_r (item) 
		end

	set_r (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `r`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_r (item, a_value.item)
		ensure
			r_set: attached r as l_value implies l_value.item = a_value.item
		end

	weights: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `weights`
		require
			exists: exists
		do
			if attached c_weights (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_weights (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_weights (item) 
		end

	set_weights (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `weights`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_weights (item, a_value.item)
		ensure
			weights_set: attached weights as l_value implies l_value.item = a_value.item
		end

	c_prev: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `c_prev`
		require
			exists: exists
		do
			if attached c_c_prev (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_c_prev (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_c_prev (item) 
		end

	set_c_prev (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `c_prev`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_c_prev (item, a_value.item)
		ensure
			c_prev_set: attached c_prev as l_value implies l_value.item = a_value.item
		end

	resfac: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `resfac`
		require
			exists: exists
		do
			if attached c_resfac (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_resfac (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_resfac (item) 
		end

	set_resfac (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `resfac`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_resfac (item, a_value.item)
		ensure
			resfac_set: attached resfac as l_value implies l_value.item = a_value.item
		end

	psi: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `psi`
		require
			exists: exists
		do
			if attached c_psi (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_psi (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_psi (item) 
		end

	set_psi (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `psi`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_psi (item, a_value.item)
		ensure
			psi_set: attached psi as l_value implies l_value.item = a_value.item
		end

	dpsi: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `dpsi`
		require
			exists: exists
		do
			if attached c_dpsi (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_dpsi (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_dpsi (item) 
		end

	set_dpsi (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `dpsi`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_dpsi (item, a_value.item)
		ensure
			dpsi_set: attached dpsi as l_value implies l_value.item = a_value.item
		end

	qsi: detachable GSL_MATRIX_STRUCT_API 
			-- Access member `QSI`
		require
			exists: exists
		do
			if attached c_qsi (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_qsi (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_qsi (item) 
		end

	set_qsi (a_value: GSL_MATRIX_STRUCT_API) 
			-- Set member `QSI`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_qsi (item, a_value.item)
		ensure
			qsi_set: attached qsi as l_value implies l_value.item = a_value.item
		end

	d: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `D`
		require
			exists: exists
		do
			if attached c_d (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_d (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_d (item) 
		end

	set_d (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `D`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_d (item, a_value.item)
		ensure
			d_set: attached d as l_value implies l_value.item = a_value.item
		end

	workn: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `workn`
		require
			exists: exists
		do
			if attached c_workn (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_workn (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_workn (item) 
		end

	set_workn (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `workn`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_workn (item, a_value.item)
		ensure
			workn_set: attached workn as l_value implies l_value.item = a_value.item
		end

	stats: GSL_MULTIFIT_ROBUST_STATS_STRUCT_API
			-- Access member `stats`
		require
			exists: exists
		do
			create Result.make_by_pointer ( c_stats(item) )
		ensure
			result_not_void: Result.item = c_stats (item) 
		end

	set_stats (a_value: GSL_MULTIFIT_ROBUST_STATS_STRUCT_API) 
			-- Set member `stats`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_stats (item, a_value.item)
		ensure
			stats_set: stats.item = a_value.item
		end

	multifit_p: detachable GSL_MULTIFIT_LINEAR_WORKSPACE_STRUCT_API 
			-- Access member `multifit_p`
		require
			exists: exists
		do
			if attached c_multifit_p (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_multifit_p (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_multifit_p (item) 
		end

	set_multifit_p (a_value: GSL_MULTIFIT_LINEAR_WORKSPACE_STRUCT_API) 
			-- Set member `multifit_p`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_multifit_p (item, a_value.item)
		ensure
			multifit_p_set: attached multifit_p as l_value implies l_value.item = a_value.item
		end

feature {NONE} -- Implementation wrapper for struct gsl_multifit_robust_workspace

	sizeof_external: INTEGER 
		external
			"C inline use <eif_gsl.h>"
		alias
			"sizeof(gsl_multifit_robust_workspace)"
		end

	c_n (an_item: POINTER): INTEGER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->n
			]"
		end

	set_c_n (an_item: POINTER; a_value: INTEGER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->n =  (size_t)$a_value
			]"
		ensure
			n_set: a_value = c_n (an_item)
		end

	c_p (an_item: POINTER): INTEGER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->p
			]"
		end

	set_c_p (an_item: POINTER; a_value: INTEGER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->p =  (size_t)$a_value
			]"
		ensure
			p_set: a_value = c_p (an_item)
		end

	c_numit (an_item: POINTER): INTEGER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->numit
			]"
		end

	set_c_numit (an_item: POINTER; a_value: INTEGER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->numit =  (size_t)$a_value
			]"
		ensure
			numit_set: a_value = c_numit (an_item)
		end

	c_maxiter (an_item: POINTER): INTEGER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->maxiter
			]"
		end

	set_c_maxiter (an_item: POINTER; a_value: INTEGER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->maxiter =  (size_t)$a_value
			]"
		ensure
			maxiter_set: a_value = c_maxiter (an_item)
		end

	c_type (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->type
			]"
		end

	set_c_type (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->type =  (gsl_multifit_robust_type const*)$a_value
			]"
		ensure
			type_set: a_value = c_type (an_item)
		end

	c_tune (an_item: POINTER): REAL_64
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->tune
			]"
		end

	set_c_tune (an_item: POINTER; a_value: REAL_64) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->tune =  (double)$a_value
			]"
		ensure
			tune_set: a_value = c_tune (an_item)
		end

	c_r (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->r
			]"
		end

	set_c_r (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->r =  (gsl_vector*)$a_value
			]"
		ensure
			r_set: a_value = c_r (an_item)
		end

	c_weights (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->weights
			]"
		end

	set_c_weights (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->weights =  (gsl_vector*)$a_value
			]"
		ensure
			weights_set: a_value = c_weights (an_item)
		end

	c_c_prev (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->c_prev
			]"
		end

	set_c_c_prev (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->c_prev =  (gsl_vector*)$a_value
			]"
		ensure
			c_prev_set: a_value = c_c_prev (an_item)
		end

	c_resfac (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->resfac
			]"
		end

	set_c_resfac (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->resfac =  (gsl_vector*)$a_value
			]"
		ensure
			resfac_set: a_value = c_resfac (an_item)
		end

	c_psi (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->psi
			]"
		end

	set_c_psi (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->psi =  (gsl_vector*)$a_value
			]"
		ensure
			psi_set: a_value = c_psi (an_item)
		end

	c_dpsi (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->dpsi
			]"
		end

	set_c_dpsi (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->dpsi =  (gsl_vector*)$a_value
			]"
		ensure
			dpsi_set: a_value = c_dpsi (an_item)
		end

	c_qsi (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->QSI
			]"
		end

	set_c_qsi (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->QSI =  (gsl_matrix*)$a_value
			]"
		ensure
			qsi_set: a_value = c_qsi (an_item)
		end

	c_d (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->D
			]"
		end

	set_c_d (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->D =  (gsl_vector*)$a_value
			]"
		ensure
			d_set: a_value = c_d (an_item)
		end

	c_workn (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->workn
			]"
		end

	set_c_workn (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->workn =  (gsl_vector*)$a_value
			]"
		ensure
			workn_set: a_value = c_workn (an_item)
		end

	c_stats (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				&((gsl_multifit_robust_workspace*)$an_item)->stats
			]"
		end

	set_c_stats (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->stats =  *(gsl_multifit_robust_stats*)$a_value
			]"
		end

	c_multifit_p (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->multifit_p
			]"
		end

	set_c_multifit_p (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_robust_workspace*)$an_item)->multifit_p =  (gsl_multifit_linear_workspace*)$a_value
			]"
		ensure
			multifit_p_set: a_value = c_multifit_p (an_item)
		end

end
