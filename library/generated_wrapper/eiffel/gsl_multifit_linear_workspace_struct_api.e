note

	description: "This file has been generated by EWG. Do not edit. Changes will be lost!"

	generator: "Eiffel Wrapper Generator"

class GSL_MULTIFIT_LINEAR_WORKSPACE_STRUCT_API

inherit

	MEMORY_STRUCTURE

	
create

	make,
	make_by_pointer

feature -- Measurement

	structure_size: INTEGER 
		do
			Result := sizeof_external
		end

feature {ANY} -- Member Access

	nmax: INTEGER
			-- Access member `nmax`
		require
			exists: exists
		do
			Result := c_nmax (item)
		ensure
			result_correct: Result = c_nmax (item)
		end

	set_nmax (a_value: INTEGER) 
			-- Change the value of member `nmax` to `a_value`.
		require
			exists: exists
		do
			set_c_nmax (item, a_value)
		ensure
			nmax_set: a_value = nmax
		end

	pmax: INTEGER
			-- Access member `pmax`
		require
			exists: exists
		do
			Result := c_pmax (item)
		ensure
			result_correct: Result = c_pmax (item)
		end

	set_pmax (a_value: INTEGER) 
			-- Change the value of member `pmax` to `a_value`.
		require
			exists: exists
		do
			set_c_pmax (item, a_value)
		ensure
			pmax_set: a_value = pmax
		end

	n: INTEGER
			-- Access member `n`
		require
			exists: exists
		do
			Result := c_n (item)
		ensure
			result_correct: Result = c_n (item)
		end

	set_n (a_value: INTEGER) 
			-- Change the value of member `n` to `a_value`.
		require
			exists: exists
		do
			set_c_n (item, a_value)
		ensure
			n_set: a_value = n
		end

	p: INTEGER
			-- Access member `p`
		require
			exists: exists
		do
			Result := c_p (item)
		ensure
			result_correct: Result = c_p (item)
		end

	set_p (a_value: INTEGER) 
			-- Change the value of member `p` to `a_value`.
		require
			exists: exists
		do
			set_c_p (item, a_value)
		ensure
			p_set: a_value = p
		end

	a: detachable GSL_MATRIX_STRUCT_API 
			-- Access member `A`
		require
			exists: exists
		do
			if attached c_a (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_a (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_a (item) 
		end

	set_a (a_value: GSL_MATRIX_STRUCT_API) 
			-- Set member `A`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_a (item, a_value.item)
		ensure
			a_set: attached a as l_value implies l_value.item = a_value.item
		end

	q: detachable GSL_MATRIX_STRUCT_API 
			-- Access member `Q`
		require
			exists: exists
		do
			if attached c_q (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_q (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_q (item) 
		end

	set_q (a_value: GSL_MATRIX_STRUCT_API) 
			-- Set member `Q`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_q (item, a_value.item)
		ensure
			q_set: attached q as l_value implies l_value.item = a_value.item
		end

	qsi: detachable GSL_MATRIX_STRUCT_API 
			-- Access member `QSI`
		require
			exists: exists
		do
			if attached c_qsi (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_qsi (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_qsi (item) 
		end

	set_qsi (a_value: GSL_MATRIX_STRUCT_API) 
			-- Set member `QSI`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_qsi (item, a_value.item)
		ensure
			qsi_set: attached qsi as l_value implies l_value.item = a_value.item
		end

	s: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `S`
		require
			exists: exists
		do
			if attached c_s (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_s (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_s (item) 
		end

	set_s (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `S`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_s (item, a_value.item)
		ensure
			s_set: attached s as l_value implies l_value.item = a_value.item
		end

	t: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `t`
		require
			exists: exists
		do
			if attached c_t (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_t (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_t (item) 
		end

	set_t (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `t`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_t (item, a_value.item)
		ensure
			t_set: attached t as l_value implies l_value.item = a_value.item
		end

	xt: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `xt`
		require
			exists: exists
		do
			if attached c_xt (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_xt (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_xt (item) 
		end

	set_xt (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `xt`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_xt (item, a_value.item)
		ensure
			xt_set: attached xt as l_value implies l_value.item = a_value.item
		end

	d: detachable GSL_VECTOR_STRUCT_API 
			-- Access member `D`
		require
			exists: exists
		do
			if attached c_d (item) as l_ptr and then not l_ptr.is_default_pointer then
				create Result.make_by_pointer (l_ptr)
			end
		ensure
			result_void: Result = Void implies c_d (item) = default_pointer 
			result_not_void: attached Result as l_result implies l_result.item = c_d (item) 
		end

	set_d (a_value: GSL_VECTOR_STRUCT_API) 
			-- Set member `D`
		require
			a_value_not_void: a_value /= Void
			exists: exists
		do
			set_c_d (item, a_value.item)
		ensure
			d_set: attached d as l_value implies l_value.item = a_value.item
		end

	rcond: REAL_64
			-- Access member `rcond`
		require
			exists: exists
		do
			Result := c_rcond (item)
		ensure
			result_correct: Result = c_rcond (item)
		end

	set_rcond (a_value: REAL_64) 
			-- Change the value of member `rcond` to `a_value`.
		require
			exists: exists
		do
			set_c_rcond (item, a_value)
		ensure
			rcond_set: a_value = rcond
		end

feature {NONE} -- Implementation wrapper for struct gsl_multifit_linear_workspace

	sizeof_external: INTEGER 
		external
			"C inline use <eif_gsl.h>"
		alias
			"sizeof(gsl_multifit_linear_workspace)"
		end

	c_nmax (an_item: POINTER): INTEGER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->nmax
			]"
		end

	set_c_nmax (an_item: POINTER; a_value: INTEGER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->nmax =  (size_t)$a_value
			]"
		ensure
			nmax_set: a_value = c_nmax (an_item)
		end

	c_pmax (an_item: POINTER): INTEGER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->pmax
			]"
		end

	set_c_pmax (an_item: POINTER; a_value: INTEGER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->pmax =  (size_t)$a_value
			]"
		ensure
			pmax_set: a_value = c_pmax (an_item)
		end

	c_n (an_item: POINTER): INTEGER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->n
			]"
		end

	set_c_n (an_item: POINTER; a_value: INTEGER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->n =  (size_t)$a_value
			]"
		ensure
			n_set: a_value = c_n (an_item)
		end

	c_p (an_item: POINTER): INTEGER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->p
			]"
		end

	set_c_p (an_item: POINTER; a_value: INTEGER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->p =  (size_t)$a_value
			]"
		ensure
			p_set: a_value = c_p (an_item)
		end

	c_a (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->A
			]"
		end

	set_c_a (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->A =  (gsl_matrix*)$a_value
			]"
		ensure
			a_set: a_value = c_a (an_item)
		end

	c_q (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->Q
			]"
		end

	set_c_q (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->Q =  (gsl_matrix*)$a_value
			]"
		ensure
			q_set: a_value = c_q (an_item)
		end

	c_qsi (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->QSI
			]"
		end

	set_c_qsi (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->QSI =  (gsl_matrix*)$a_value
			]"
		ensure
			qsi_set: a_value = c_qsi (an_item)
		end

	c_s (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->S
			]"
		end

	set_c_s (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->S =  (gsl_vector*)$a_value
			]"
		ensure
			s_set: a_value = c_s (an_item)
		end

	c_t (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->t
			]"
		end

	set_c_t (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->t =  (gsl_vector*)$a_value
			]"
		ensure
			t_set: a_value = c_t (an_item)
		end

	c_xt (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->xt
			]"
		end

	set_c_xt (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->xt =  (gsl_vector*)$a_value
			]"
		ensure
			xt_set: a_value = c_xt (an_item)
		end

	c_d (an_item: POINTER): POINTER
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->D
			]"
		end

	set_c_d (an_item: POINTER; a_value: POINTER) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->D =  (gsl_vector*)$a_value
			]"
		ensure
			d_set: a_value = c_d (an_item)
		end

	c_rcond (an_item: POINTER): REAL_64
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->rcond
			]"
		end

	set_c_rcond (an_item: POINTER; a_value: REAL_64) 
		require
			an_item_not_null: an_item /= default_pointer
		external
			"C inline use <eif_gsl.h>"
		alias
			"[
				((gsl_multifit_linear_workspace*)$an_item)->rcond =  (double)$a_value
			]"
		ensure
			rcond_set: a_value = c_rcond (an_item)
		end

end
